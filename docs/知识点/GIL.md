---
sidebar_position: 1
---

# GIL

## 什么是GIL

`GIL`，即全局解释器锁(Global Interpreter Lock)，这是一个让人又爱又恨的机制，有了它，初学者们可以放心大胆地使用Python而无需去担心各种内存问题，但同样是因为它，让开发者有了更多的烦恼：

- 无法进行真正有效的并行操作
- 编写一些Python的三方库时不得不考虑`GIL`的复杂场景

在官方的文档中，是这样解释`GIL`的：

> (GIL是)CPython 解释器所采用的一种机制，它确保同一时刻只有一个线程在执行 Python bytecode(字节码，在Python执行时将源码编译为字节码)。此机制通过设置对象模型（包括 dict 等重要内置类型）针对并发访问的隐式安全简化了 CPython 实现。给整个解释器加锁使得解释器多线程运行更方便，其代价则是牺牲了在多处理器上的并行性。
>
> 不过，一些附加模块，例如一些标准或第三方库中会在计算密集型任务中释放GIL锁，举两个简单的例子：压缩和哈希。除此之外，GIL也经常在IO操作时释放。
>
> 创建一个（以更精细粒度来锁定共享数据的）“自由线程”解释器的努力从未获得成功，因为这会牺牲在普通单处理器情况下的性能。据信克服这种性能问题的措施将导致实现变得更复杂，从而更难以维护。

是不是听起来一头雾水？

简单的来说，`GIL`的作用是在使用多线程时保证同时有且仅有一个线程执行。如此一来，保证了多个线程同时操作同一个对象时的各种读写问题，即在同一时刻只允许一个线程读写操作一个对象。

## 为什么是GIL

至于说为什么Python选择`GIL`，我觉得可能有几个方面原因：

1. 对象采用引用计数的方式判定是否销毁(Python GC的机制)，这样就意味着多线程处理引用计数时很难兼顾性能和准确性。
2. 在易用性和性能上取舍。对于有`GIL`的Python的入门门槛会大大降低，甚至一名小学生都可以很轻松的理解并写出一个Python程序。而Python绝大多数场景下是无需过分关注性能的，即使是有性能场景，也可以通过其他的方式解决：例如用C来写，Python来调用。
3. 兼容非线程安全的C库，如此一来，Python的生态建立门槛会大大降低。

:::tip [知识点：GC](docs/知识点/GC.md)
:::
